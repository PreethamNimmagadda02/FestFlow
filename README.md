## My Details
### Preetham Nimmagadda 
### IIT(ISM) Dhanbad
### Electronics and Communication Engineering

---

## Live Application Link

You can explore the live application here: **[https://festflow.co.in/](https://festflow.co.in/)**

---

## User Documentation

**[Documentation Link](https://docs.google.com/document/d/1hJDbRjC1NHDa5bRx6qat8PNdn3Mvvyc7pmHJrxrl8vI/edit?usp=sharing)**

---

## System Design of FestFlow

### System Architecture

FestFlow is built on a modern, decoupled architecture that separates the user interface from its backend services, ensuring scalability and maintainability.

* **Frontend (Client-Side):** The core of the user experience is a dynamic Single-Page Application (SPA) built with **React** and bundled by **Vite**. This client-side application is responsible for all UI rendering, state management, and user interactions. It communicates directly with backend services for data and AI functionalities.

* **Backend-as-a-Service (BaaS):** We leverage **Firebase** to handle critical backend operations without a traditional server.
    * **Authentication:** Firebase Authentication manages user identity, supporting sign-in with Google, GitHub, and email/password. The `AuthContext` provides a clean interface for managing user state throughout the application.
    * **Database:** **Cloud Firestore**, a NoSQL document database, is used to persist all user and session data. This includes user profiles, saved event plans (sessions), and all associated tasks and logs. The data is structured hierarchically, with each user's data stored in a dedicated collection.

* **AI Logic (Generative Backend):** The application's intelligence is powered by the **Google Gemini API**. The `geminiService.ts` acts as a dedicated layer to communicate with the model. It is responsible for:
    * **Goal Decomposition:** Translating a high-level user goal into a structured array of tasks with dependencies and assignments.
    * **Content Generation:** Executing specific tasks, such as drafting sponsorship emails or creating marketing posts, based on contextual prompts.

This serverless, multi-backend approach allows the frontend to remain lightweight while offloading complex and specialized tasks to dedicated, scalable services.

### Data Design

The application's data is modeled around a few core TypeScript interfaces, ensuring type safety and clear structure. This data is stored and retrieved from Firestore documents.

* **`UserProfile`**: Stores essential user information, including their UID, email, and institution details. This forms the top-level document for each user in Firestore.
* **`SavedSession`**: Represents a complete event plan. Each user can have multiple saved sessions. A session contains the user's goal (as its name), a timestamp, and the entire application state at the time of saving.
* **`AppState`**: This is the main state object for an active plan, containing four key arrays:
    * **`Task[]`**: The heart of the application. A task object includes an ID, title, description, assigned agent (`AgentName`), dependencies (`dependsOn`), status (`TaskStatus`), and more. The system supports parent-child relationships between tasks for better organization.
    * **`Approval[]`**: Holds content generated by AI agents that requires user review. Each approval is linked to a `Task`.
    * **`ActivityLog[]`**: A running list of actions taken by the AI agents, providing a real-time feed of the system's operations.
    * **`AgentStatus` & `AgentWork`**: Records tracking the current state (e.g., Idle, Working) and active task of each AI agent.

* **Data Flow Diagram**
  <img width="867" height="693" alt="Screenshot 2025-09-26 at 11 14 06â€¯PM" src="https://github.com/user-attachments/assets/9801aae5-ded7-491e-8377-36bb0c057ebf" />

This design ensures that each event plan is a self-contained unit, making it easy to save, load, and manage distinct events for each user.
  
### Component Breakdown

The UI is built with a modular, component-based approach using React.

* **`App.tsx`**: The root component that orchestrates the entire application. It manages the main state, handles the lifecycle of the AI agents, and renders other components conditionally (e.g., showing the `LoginScreen` vs. the `Dashboard`).
* **Authentication Flow (`LoginScreen.tsx`, `CompleteProfileModal.tsx`)**: A dedicated set of components for handling user sign-in, sign-up, and the one-time profile completion step.
* **`Dashboard.tsx`**: The central workspace where users monitor and interact with their event plan. It contains:
    * **`AgentStatusGrid` & `AgentActivityFeed`**: For real-time monitoring of the AI agents.
    * **`TaskLane` (Kanban View)**: Displays tasks organized by their assigned agent, providing a clear view of each agent's workload.
    * **`GanttChart.tsx`**: An alternative timeline view that visualizes task dependencies and durations, allowing for interactive rescheduling.
* **Modal System (`TaskDetailModal.tsx`, `LoadSessionModal.tsx`, etc.)**: A suite of modal components for focused interactions like viewing task details, loading saved sessions, or confirming actions. This keeps the main dashboard clean while providing rich functionality on demand.

### Chosen Technologies

The technology stack was chosen to facilitate rapid development, ensure a high-quality user experience, and leverage powerful, scalable backend services.

* **React & TypeScript**: Chosen for building a modern, type-safe, and maintainable user interface. React's component model is ideal for creating the modular UI elements seen throughout the application.
* **Vite**: Selected as the frontend build tool for its incredibly fast development server and optimized build process, which significantly improves developer productivity.
* **Firebase**: A comprehensive platform that provides essential backend services out-of-the-box.
    * **Firestore & Firebase Auth**: These were chosen to handle data persistence and user authentication securely and scalably, without the need to build and maintain a custom backend server.
* **Google Gemini API**: The core of the application's intelligence. Gemini was chosen for its advanced reasoning capabilities and its ability to return structured JSON, which is essential for reliably decomposing goals into a machine-readable task format.
* **Tailwind CSS**: A utility-first CSS framework used for styling. It allows for rapid and consistent UI development directly within the HTML, as seen in the extensive and clean styling of the components.
---

### Growth Strategy

### Phase 3: Real-World Integration and Automation

* **Notifications:** Implement a notification system to alert users of important events, such as when a task is completed or an approval is required.

* **API Integrations:**
    * **LogisticsCoordinatorAgent:** Connect to Calendar API to automatically schedule events and reminders. Integrate with mapping services like Maps for venue and travel planning.
    * **SponsorshipOutreachAgent:** Integrate with email services like the Gmail API to allow the agent to send outreach emails directly (after user approval).
    * **MarketingAgent:** Connect to social media APIs (e.g., Twitter, Facebook) to schedule and post promotional content.
* **Vendor and Contact Management:** Add a dedicated section for managing contacts, such as sponsors, vendors, and team members. This could include contact information, communication history, and status.

### Phase 4: Collaboration and Scalability

* **Multi-User Collaboration:**
    * Introduce user accounts and roles (e.g., Event Manager, Marketing Lead, Finance Officer).
    * Implement real-time collaboration features, allowing multiple users to work on the same event plan simultaneously.
    * Add a commenting system for tasks to facilitate team communication.
* **Event Templates:** Allow users to save successful event plans as templates for future use. This would streamline the setup process for recurring or similar events.

### Phase 5: Advanced AI and Analytics

* **New AI Agents:**
    * **FinanceAgent:** An agent dedicated to managing the event budget, tracking expenses, and providing financial reports.
    * **VendorAgent:** An agent that can research and suggest potential vendors based on the event's requirements.
* **Learning and Adaptation:** Enhance the AI agents to learn from user feedback. For example, if a user frequently edits marketing copy to be more "energetic," the `MarketingAgent` could adapt its writing style in the future.
* **Analytics Dashboard:** Create a dashboard that provides analytics and insights into the event's progress, such as:
    * Social media engagement for marketing posts.
    * Response rates from sponsorship emails.
    * Budget tracking and expense analysis.
* **Predictive Analysis:** In a more advanced stage, the AI could use data from past events to predict potential bottlenecks, suggest more efficient timelines, or forecast budget requirements.



## Run Locally

**Prerequisites:**  Node.js

1. Install dependencies:
   `npm install`
2. Set the `VITE_GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


 ## Interaction logs

Link: https://g.co/gemini/share/2168e6ca076c

<a href="https://www.linkedin.com/in/preethamnimmagadda" target="_blank">
  <img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="Preetham Nimmagadda"/>
 </a>
