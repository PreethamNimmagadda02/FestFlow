## My Details
### Preetham Nimmagadda 
### IIT(ISM) Dhanbad
### Electronics and Communication Engineering

---

## Live Application Link

You can view the live application here: **[https://festflow.co.in/](https://festflow.co.in/)**

---

## System Design Documentation of FestFlow

### System Architecture

FestFlow is built on a modern, decoupled architecture that separates the user interface from its backend services, ensuring scalability and maintainability.

Frontend (Client-Side): The core of the user experience is a dynamic Single-Page Application (SPA) built with React and bundled by Vite. This client-side application is responsible for all UI rendering, state management, and user interactions. It communicates directly with backend services for data and AI functionalities.

Backend-as-a-Service (BaaS): We leverage Firebase to handle critical backend operations without a traditional server.

Authentication: Firebase Authentication manages user identity, supporting sign-in with Google, GitHub, and email/password. The AuthContext provides a clean interface for managing user state throughout the application.

Database: Cloud Firestore, a NoSQL document database, is used to persist all user and session data. This includes user profiles, saved event plans (sessions), and all associated tasks and logs. The data is structured hierarchically, with each user's data stored in a dedicated collection.

AI Logic (Generative Backend): The application's intelligence is powered by the Google Gemini API. The geminiService.ts acts as a dedicated layer to communicate with the model. It is responsible for:

Goal Decomposition: Translating a high-level user goal into a structured array of tasks with dependencies and assignments.

Content Generation: Executing specific tasks, such as drafting sponsorship emails or creating marketing posts, based on contextual prompts.

This serverless, multi-backend approach allows the frontend to remain lightweight while offloading complex and specialized tasks to dedicated, scalable services.

### Data Design

The application's data is modeled around a few core TypeScript interfaces, ensuring type safety and clear structure. This data is stored and retrieved from Firestore documents.

UserProfile: Stores essential user information, including their UID, email, and institution details. This forms the top-level document for each user in Firestore.

SavedSession: Represents a complete event plan. Each user can have multiple saved sessions. A session contains the user's goal (as its name), a timestamp, and the entire application state at the time of saving.

AppState: This is the main state object for an active plan, containing four key arrays:

Task[]: The heart of the application. A task object includes an ID, title, description, assigned agent (AgentName), dependencies (dependsOn), status (TaskStatus), and more. The system supports parent-child relationships between tasks for better organization.

Approval[]: Holds content generated by AI agents that requires user review. Each approval is linked to a Task.

ActivityLog[]: A running list of actions taken by the AI agents, providing a real-time feed of the system's operations.

AgentStatus & AgentWork: Records tracking the current state (e.g., Idle, Working) and active task of each AI agent.

This design ensures that each event plan is a self-contained unit, making it easy to save, load, and manage distinct events for each user.
* **Data Flow Diagram**
  <img width="867" height="693" alt="Screenshot 2025-09-26 at 11 14 06â€¯PM" src="https://github.com/user-attachments/assets/9801aae5-ded7-491e-8377-36bb0c057ebf" />

  
### Component Breakdown

The user interface is composed of a series of modular **React components**.

* **`App.tsx`**: The main application component that manages the overall state and orchestrates the interactions between UI components and the backend Gemini service.
* **`Dashboard.tsx`**: The central hub of the application, providing an overview of the event plan. It includes an Agent Status Grid, an Agent Activity Feed, and a Task Progress section with both Kanban and Gantt chart views.
* **`TaskLane.tsx`**: A component in the Kanban view that displays all tasks assigned to a specific agent.
* **`ApprovalCard.tsx`**: A component for handling content that requires user approval, displaying AI-generated content with buttons to approve or reject it.
* **`GanttChart.tsx`**: An alternative view for visualizing task dependencies and timelines.
* **`FestivalSetupForm.tsx`**: The initial form where users input their high-level event goals, which triggers the AI planning process.

### Chosen Technologies

The technologies for FestFlow were selected to prioritize **rapid development**, **scalability**, and a **modern user experience**.

* **React**: A JavaScript library for building user interfaces, chosen for its component-based architecture which supports a modular and maintainable application.
* **Tailwind CSS**: A utility-first CSS framework that enables rapid styling and ensures a consistent design.
* **Google Gemini API**: A large language model that serves as the application's intelligent backend, handling goal decomposition and content generation.
* **Vite**: A frontend build tool that offers a fast development server and optimized build process, enhancing developer productivity and application performance.
---

### Growth Strategy

### Phase 3: Real-World Integration and Automation

* **Notifications:** Implement a notification system to alert users of important events, such as when a task is completed or an approval is required.

* **API Integrations:**
    * **LogisticsCoordinatorAgent:** Connect to Calendar API to automatically schedule events and reminders. Integrate with mapping services like Maps for venue and travel planning.
    * **SponsorshipOutreachAgent:** Integrate with email services like the Gmail API to allow the agent to send outreach emails directly (after user approval).
    * **MarketingAgent:** Connect to social media APIs (e.g., Twitter, Facebook) to schedule and post promotional content.
* **Vendor and Contact Management:** Add a dedicated section for managing contacts, such as sponsors, vendors, and team members. This could include contact information, communication history, and status.

### Phase 4: Collaboration and Scalability

* **Multi-User Collaboration:**
    * Introduce user accounts and roles (e.g., Event Manager, Marketing Lead, Finance Officer).
    * Implement real-time collaboration features, allowing multiple users to work on the same event plan simultaneously.
    * Add a commenting system for tasks to facilitate team communication.
* **Event Templates:** Allow users to save successful event plans as templates for future use. This would streamline the setup process for recurring or similar events.

### Phase 5: Advanced AI and Analytics

* **New AI Agents:**
    * **FinanceAgent:** An agent dedicated to managing the event budget, tracking expenses, and providing financial reports.
    * **VendorAgent:** An agent that can research and suggest potential vendors based on the event's requirements.
* **Learning and Adaptation:** Enhance the AI agents to learn from user feedback. For example, if a user frequently edits marketing copy to be more "energetic," the `MarketingAgent` could adapt its writing style in the future.
* **Analytics Dashboard:** Create a dashboard that provides analytics and insights into the event's progress, such as:
    * Social media engagement for marketing posts.
    * Response rates from sponsorship emails.
    * Budget tracking and expense analysis.
* **Predictive Analysis:** In a more advanced stage, the AI could use data from past events to predict potential bottlenecks, suggest more efficient timelines, or forecast budget requirements.



## Run Locally

**Prerequisites:**  Node.js

1. Install dependencies:
   `npm install`
2. Set the `VITE_GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


 ## Interaction logs

Link: https://g.co/gemini/share/2168e6ca076c
